\section{The Model}
\label{tree:sorting:model}

An important remark to begin with is that we will generally not be interested
into the \emph{machine-world} complexity of a problem. As always, we have to
define a model of computation that tells us which operations are allowed, which
not and what are the cost for each of them.

From here till the end we will work in the \defineconcept{Decision Tree Model}:
we are allowed to ask questions to an oracle \(\le\) that will be answered yes or
no hence each question we ask to this oracle will at most give us one
additional bit of information.

Each question asked to the oracle will cost us $1$ unit of some resource.
Every other operation can be carried out for free. Indeed, solving a problem in
our model will amount to retrieve a certain quantity of information. We will
need to find ways to organize the retrieved information and exploit already
known information. If done efficiently, we will solve our problems without
asking to many questions to our oracle.

The goal of each of our expeditions will be either to show that at least a
certain number of questions are required to be asked to solve a specific
problem, or to provide an algorithm that asks no more questions than a certain
limit. Those two kinds of discoveries are respectively called lower and upper
bounds.

Further down the road we will trade our binary oracle for a
ternary one. However, for the first few chapters, we will content ourselves
with the binary oracle.
