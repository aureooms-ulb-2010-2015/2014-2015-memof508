\section{Efficient Implementation of Linial's Algorithm}

However, as an anonymous referee pointed out in the peer review of
\citet*{cardinal:2013}, there exists a faster way that does not require computing
all those determinants. We now expose a recurrence relation that can be used
to compute \(e(\P)\) with dynamic programming.

We look at \(a_m\) and \(b_n\). There are three ways \(a_m\) and \(b_n\) can be
related in the partial order we receive as input. Either we know \(a_m < b_n\)
or \(a_m > b_n\), or \(a_m\) and \(b_n\) are incomparable in this partial
order. In the first two cases, we know that one of \(a_m,b_n\) must be the last
element of the set \(\A \cup \B\) when totally ordered. In these cases, \(e(\P) =
e(\P \setminus b_n)\) or \(e(\P) = e(\P \setminus a_m)\) for \(a_m < b_n\) or
\(a_m > b_n\) respectively. Now, if \(a_m\) and \(b_n\) are incomparable in
\(\P\), in the totally ordered set we are building one of \(a_m < b_n\) or \(a_m
> b_n\) holds true. Hence \(e(\P) = e(\P \setminus b_n) + e(\P \setminus
a_m)\) in this case, since both outcomes for \(a \ask{<} b\) are possible.
Lastly, if \(\card{\A} = 0\) or \(\card{\B} = 0\) then \(e(\P) = 1\). We can thus
express \(e(\P)\) using the following recurrence relation

\begin{displaymath}
e(\P) =
\begin{dcases*}
1            & if \(\card{\A} = 0\) or \(\card{\B} = 0\)\\
e(\P \setminus b_n) & if \(a_m < b_n\)\\
e(\P \setminus a_m) & if \(a_m > b_n\)\\
e(\P \setminus b_n) + e(\P \setminus a_m) & if \(a_m\) and \(b_n\) are
incomparable.\\
\end{dcases*}
\end{displaymath}

Note that if we compute \(e(\P)\) using this recurrence in a dynamic program,
we also get all values of \(e(\P(a_m < b_s))\) and \(e(\P(a_s < b_n))\) for
free. This is because there is only one possible way tail elements can be
arranged to have \(e(\P(a_m < b_s))\), \ie \(a_m < b_s < b_{s+1} < \ldots <
b_n\). Note that other values \(e(\P(a_i < b_j)\) for any pair \((a_i,b_j)\)
would be trickier to compute. The value of \(e(\P)\) and the number of linear
extensions of all poset extensions \(\P(a_m < b_s)\) and \(\P(a_s < b_n)\) can
thus be computed in \BigO{mn \log e(\P)} time using dynamic programming with a
\(m \times n\) memory tableau containing numbers with values up to \(\log
e(\P)\). Note that posets that are incompatible with the original poset \(\P\),
are assigned a value \(e = 0\).

Moreover, one can reuse the information obtained via the dynamic program. We
explain how. Suppose we have computed \(e(\P)\) and all \(e(\P(a_m < b_s))\) and
\(e(\P(a_s < b_n))\) using the dynamic program. According to these values and
thanks to Linial's proof, we find a good query \(a_m \ask{<} b_s\) to perform.
Depending on the outcome of this query we update the output of the dynamic
program. If \(a_m < b_s\) then we do not have to update anything,
\(\chain{b_s}{b_n}\) can now simply be ignored. Otherwise, \(a_m > b_s\) and
unless \(s = n\) we have to update at most \(s\) cells of the dynamic program
tableau. If the memory tableau of the dynamic program is a \(m \times n\)
tableau \(e = \enum{e_{i,j} = e(\chain{a_1}{a_i} \cup \chain{b_1}{b_j})}\), the
cells to update are \(e_{m,t}\) through \(e_{m,s}\) where \(t \le s\) is \( t =
\min \enum{t \st a_m \text{ and } b_t \text{ are incomparable} }\).

As a final remark, know that it is possible to reduce the computational
complexity of both the construction and the update of the dynamic program. If
we limit ourselves to store \emph{limited precision integers} and perform
\emph{limited precision arithmetic} when adding those integers, then we can
shave off the \(\log e(\P)\) factor in both cases. Hence, if we divide the
execution of the algorithm into a preprocessing phase and a processing phase,
the complexity of the preprocessing phase is \BigO{mn} while doing no
comparisons, and the complexity of the processing phase is \BigO{N \log e(\P)}
using \BigO{\log e(\P)} comparisons where \(N = \max \enum{m,n}\).
